1. 경로 필터링
http 메서드가 다르다면 같은 경로를 사용하더라도 구분할 수 있다.
ex) app.use('/admin',router);
=> admin이라는 경로가 앞에 붙어있어야 router에 접근할 수 있다.
=> 즉, 공통된 URL를 가질 수 있다.
=> admin/add/product라는 경로가 있다면 app.use(admin, router)으로 1차 검증을 통해 router 핸들러로 간다. 이 후 admin는 다시 확인하지않고 add/product 경로를 확인하고 함수를 실행한다.


2. HTML 페이지 서비스하기
res.sendFile() => 사용자에게 파일을 회신할 수 있으며 Content-Type이 자동으로 response header로 설정된다.
sendFile의 경로를 구축하려면 Node.js가 제공하는 기능을 사용해야 한다.
코어 모듈인 path를 require하고 path.join()를 사용하여 경로를 생성한다.

join()은 마지막에 경로를 출력한다. 그리고 여러 세그먼트를 이어 붙여서 경로를 구축한다.
첫 번쨰 인수로는 Node.js의 전역 변수를 사용한다. => __(밑줄 두 개 )dirname이라고 하고 절대 경로를 이 프로젝트 폴더로 고정해 주는 전역 변수이다. 두 번쨰 인수부터 해당 프로젝트부터 경로를 구축한다.

join()를 사용하는 이유는 자동으로 리눈스와 윈도우 시스템 모두에서 작동하는 방식으로 경로를 생성해 주기 때문이다.
윈도우의 경로는 백슬래시이고 리눅스의 경로는 슬래시로 구축한다. join은 실행중인 운영체제를 감지해서 자동으로 올바른 경로를 생성한다.

여기서 dirname은 routes 폴더를 가르킨다. __dirname은 자신이 사용된 파일의 경로를 알려준다.


3. 내비게이션을 위한 헬퍼 함수 사용
join() 경로를 구축할 떄 ../ 대신 ..를 사용하여 경로를 구축할 수 있다.
helper 함수의 도움을 받아 상위 디렉터리를 얻을 수 있다.

1. JS 파일을 생성한다.
2. path 코어 모듈을 require한다.
3. module.exports = path.dirname();
(dirname은 경로의 폴더 이름을 회신한다.)
4. dirname()의 인자로 전역 프로세스 변수를 사용하면 된다. => process
5. dirname(process.mainModule) => 애플리케이션을 시작한 주요 모듈을 나타낸다.
6. dirname(process.mainModule.filename) => 파일이름을 알아낸다.
=> process.mainModule.filename => 애플리케이션이 실행될 수 있도록 해주는 파일의 경로를 알려준다.
(process.mainModule.filename은 사라졌기 때문에 require.main.filename으로 대체한다.)
=> dirname 안에 있기 때문에 디렉터리의 경로를 알아낼 수 있다.


4. 정적으로 파일 서비스하기
사용자에게 항상 공개되는 내용의 파일들의 폴더명을 public이라고 짓는 것이 관례이다.

기본적인 파일들은 사용자들이 엑세스 할 수 없다. => 파일시스템 자체에 접근할 수 없다.
but 예외를 만들 수 있다. 특정 요청이 파일 시스템에 접근할 수 있도록 하는 것이다.
=> css link를 통해 접근할 수는 없다. 거부한다.

ex) app.use(express.static())
=> 정적 파일을 서비스한다. 어떤 파일을 찾으려는 요청이 있을 떄 (반환해야 하는 HTML파일에서 link태그의 href가 존재할 경우 해당 경로를 직접 엑세스 하도록 하고 루트 폴더를 알려준다.)
=> CSS나 JS를 파일을 직접적으로 엑세스한다.
=> 반환해야하는 HTML의 link의 href는 루트 폴더를 제외하고 적어야 한다. 루트 폴더의 경로는 이미 static에서 제공했기 때문이다.


































