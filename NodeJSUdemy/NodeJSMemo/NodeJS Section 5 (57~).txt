1. Express.js란?
서버로직을 전부 처리하는 코드를 만드는 것은 번거롭고 반복적이다.
비지니스 로직에 집중하고 세부적인 사항에 관해서는 구축되거나 설정되기를 원한다. => 프레임워크
어플리케이션이나 코드를 어떤 구조로 구축해야 할지 어떻게 작업해야 할 지에 대해 뚜렷하게 정의된 방식 => 프레임워크

Express.js의 대안으로 Adonis.js, KOA, Sails 등이 존재한다.
Express.js의 장점은 매우 유연하고 특별한 기능들을 과도하게 추가하지 않고 높은 확장성을 가지고 있다.

2. Express.js 설치
npm install --save express
=> 개발 뿐만 아니라 배포까지 고려하기 떄문에 --save를 사용했다.

const app = require('express') => 함수 호출로 인해 해당 프레임워크가 배후에서 많은 내용을 저장 및 관리하게 된다.
들어오는 요청을 처리하는 특정 방식을 설정하는데 이것이 바로 Express.js를 정의하며 핵심 특성이기도 하다.


3. 미들웨어 추가
Express.js는 미들웨어와 깊게 연관되어 있다. 
미들웨어의 뜻은 들어오는 요청을 express.js에 의한 다양한 함수를 통해 자동으로 이동하는 것이다.
단일 요청 핸들러를 보유하는 대신 응답을 전송하기 전까지 요청이 통과하게 될 다양한 함수들을 연결할 가능성을 확보하게 된다.

app.use() 
=> 요청 핸들러이며 3가지 인수를 받는다. req, res, next
next는 함수이고 다음 미들웨어로 요청이 이동할 수 있도록 실행되어야 한다.
next()의 호출은 다음 라인에 있는 미들웨어로 요청을 이동시키라는 뜻이다.

=> 요청이 다음 라인에 있는 미들웨어로 이동할 수 있게 하는 메서드 next();


4. 미들웨어 작동 방식
Express.js는 기본 응답을 보내지 않는다. 
응답전송을 하고 싶다면 use의 두 번쨰 인자를 사용하면 된다. next()는 필요없게 된다.

app.use((req, res, next) =>{
  res.send('<h1>Hello</h1>')
})
=> content-Type : text/html이 자동으로 설정되어 있다. Express의 기능이다. send() 메서드는 기본 기능으로 응답 헤더가 text/html이다.

=> next()를 사용해서 위에서 아래로 미들웨어의 흐름을 제어한다.


5. Express.js 백그라운드 확인
const server = http.createServer(app)
server.listen(3000)
=> app.listen(), express.js가 내부적으로 처리해준다.

send()의 기본동작은 첫 번쨰 인수에 의해 결정된다. => Express.js github에 가면 확인할 수 있다.


6. 다른 라우트 사용법
use() 메서드를 사용하는 여러 방법이 존재한다.

app.use([path], callback, [callback...])
첫 번째 인수를 통해 특정 요청만을 걸러낼 수 있다.
두 번째 인수는 콜백이고 실행해야 하는 함수이다.
콜백은 하나 이상 설정할 수 있고 다중 경로 필터를 설절할 수 도 있다.

path를 사용할 떄 '/'는 기본값이다.
만약 path를 /만 주었을 때는 /뒤에 무엇을 붙여도 접근이 가능하다. => /라는 의미가 아니라 /로 시작해야 하기 때문이다.
모든 라우트는 /로 시작한다.

하나 이상의 응답을 보내려 하면 오류가 발생하기 때문에 응답을 보낼 때는 next()를 호출하지 않는 것이 좋다.

*** /는 /로 시작하는 모든 요청에 응답한다.


7. 수신 요청 분석
res.redirect() => 리다이렉트한다. 다른 페이지로 이동한다.
req.body => req는 들어오는 요청의 본문을 분석하려고 하지 않는다. 또 다른 미들웨어를 추가해서 데이터를 읽어들어야 한다.

데이터를 읽는 미들웨어는 대체적으로 위로 두는데 요청이 어디로 향하든 본문 분석이 이루어지도록 하기 위해서이다.
npm install --save body parser
기본적으로 Express에 포함되어 있다. 과거에 포함되어 있다가 빠졌다가 다시 추가되었다. => 이후에 해당 패키지가 이탈하더라도 코드를 사용하기 위해 설치한다.

app.use(bodyParser.urlencoded(extneded: false))
=> 자동으로 미들웨어들에 들어오는 요청 본문을 해석한다. 다만 파일같은 특정 데이터는 불가하다. 다른 패키지를 사용하면 된다. 
=> extended : false, 비표준 대상의 분석이 가능한지를 나타낸다.



































