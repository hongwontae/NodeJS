1. 응답 전송
res 객체는 나가야할 응답에 대한 정보를 담고 있다.
res.setHeaders(1,2) => 첫 번쨰 인자는 헤더를 설정한다. 두 번쨰 인자는 헤더의 데이터 종류를 설정한다.
=> ('Content-Type','text/html')
=> 헤더를 설정하지 않으면 브라우저가 데이터 양식을 이해하지 못해서 오류가 발생한다.
res.write() => 데이터를 담을 수 있다. 서블릿처럼 write를 연속으로 사용하여 HTML를 구성한다.
res.end() => 응답의 생성이 끝난 뒤에는 노드에게 알려야 한다. 메서드가 호출된 다음의 코드는 오류가 발생한다.


2. 라우터 요청
<form> 태그의 속성
action => 전송할 서버의 url
methid => 전송될 http method

<input>의 속성
name => 보내는 데이터의 키역할을 한다고 보면 된다.

form 태그의 button의 type이 submit이라면 자동으로 input의 데이터가 서버로 전송된다.
받는 url는 문자열이다.


3. 요청 리디렉션
req에서 받는 모든 정보는 String이다.
응답을 확인하기 위해 응답이 들어오면 file를 생성하고 statusCode = 302와 headers(Location,/)를 설정한다.
=> 파일이 생성되고 다시 /로 돌아온다.


4. 요청 본문 분석

Stream and Butter
스트림은 지속적인 프로세스이다. 노드가 요청을 한 청크 단위로 읽는다. 다 읽고 나면 이때부터 요청 전체를 읽기까지 기다리지 않고도 각각의 청크를 다룰 수 있다. 하지만 코드를 사용해 청크를 마음대로 다룰 수는 없다.

청크를 체계화하기 위해 버퍼를 이용한다. 버퍼는 여러 개의 청크를 보유하고 파싱이 끝나기 전에 작업할 수 있도록 한다.

req.on('data') => 특정 이벤트 리스너를 등록할 수 있다. 이벤트 트리거 data는 새 청크가 읽힐 준비가 될 떄마다 데이터 이벤트가 발생하는데 버퍼가 도움을 준다.

req.on('end') => 들어오는 요청 데이터 혹은 전반적인 요청을 분석한 후에 발생한다.

* 이벤트 핸들러나 이벤트 리스너는 addEventListener('click',func(){}) 전체를 의미하는 것이다.


5. 이벤트 기반 코드 실행의 이해
Node.js는 콜백함수를 비동기처리한다. => 콜백함수가 무조건 비동기처리되는 함수는 아니지만 Node.js는 대부분 콜백함수는 비동기처리된다.
Node.js는 이벤트 리스너를 만나면 내부적으로 등록한 후 관리한다.


6. 블로킹 및 논블로킹 코드
fs.writeFileSync => 동기화 코드이다. 파일이 쓰여질 떄까지 모든 코드 진행을 막는다. 콜스택이 비워지지 않는다.
비동기 처리는 Node.js가 멀티 스렝딩을 사용하는 운영체제에 전달하며 이벤트 콜백을 파악하기 위해 이벤트 루프를 계속하면서 코드 실행을 원활히 하고 운영체제에서 작업이 끝난 뒤에는 콜스택으로 전달된다.


























