1. 파일 피커
1-1. input type = "file"로 지정하면 기본적인 파일 피커가 생성된다.


2. Multipart-Form-Data
2-1. 파일 자체는 이진법으로 이루어진 데이터이기 떄문에 일반적인 방법으로 추출할 수 없다. => bodyParser로 접근할 수 없다.

2-2. 여러 부분으로 구성: 폼 데이터와 파일은 각각 별도의 부분으로 나뉘어 전송됩니다.
2-3. 파일 업로드 지원: 파일 업로드 시에는 파일의 데이터와 메타데이터(파일 이름 등)를 포함하여 전송할 수 있습니다.
2-4. Boundary 구분: 각 부분은 고유한 Boundary 문자열로 구분됩니다.

2-5. FormData 객체는 자동으로 multipart/form-data 형식으로 인코딩하여 서버로 전송된다.
=> 이 떄 headers가 자동으로 설정된다. headers: { 'Content-Type': 'multipart/form-data' }

2-6. 멀티파트 형식의 구조
1. formdata.append('email', email)/ formdata.append('password',password)
=> 각 append 추가 데이터가 하나의 파트이다. 이를 고유한 문자열인 바운더리로 구분한다.

2. Content-Disposition:
=> 하나의 파트에 데이터 유형과 이름을 정의

3. Content-Type
=> 파일의 MIME 타입 (텍스트 데이터는 생략가능)

4. (binary data): 파일의 실제 바이너리 데이터.

=> 모든 파트는 하나의 연속적인 2진 데이터 스트림으로 인코딩된다.

5. multipart 형식은 요청 헤더와 요청 본문으로 나뉘어진다.
=> 요청 헤더에는 멀티 파트 데이터임을 알리는 header와 각 파트를 구분하기 위해 바운더리가 존재
=> 요청 헤더의 바운더리가 각 파트의 구분자이다.

=> 요청 본문은 각 파트의 데이터 타입에 따라 Content-Type이 다르게 설정된다./ 텍스트의 경우 생략 가능
=> 파일의 경우 Content-Type: image/jpeg 처럼 필요하다.


3. Multer
=> 요청 파일 데이터을 분석할 수 있다.
=> 파일 데이터 + 텍스트 데이터 혼합해서 처리가능
=> 클라이언트의 req headers가  multipart/form-data라면 Multer 미들웨어를 통해서 각 부분을 분석하여 폼 데이터 및 파일
데이터를 추출할 수 있다.

3-1. multer.diskStorage
1. 파일을 특정 디렉토리에 저장할 수 있고, 파일명과 경로를 커스터마이징할 수 있다.

2. 인자에 객체를 받아들인다.
2-1. 저장 경로 설정/ 2-2. 파일명 설정
multer.diskStorage({
    destination : (req, file, cb)=>{
        cb(null, 'uploads/')
    }, => req는 요청 객체, file은 파일 객체, cb는 첫 번쨰 인자는 에러, 두 번째 인자는 저장될 디렉토리 경로
    filename: (req, file, cb) => {
    cb(null, Date.now() + '-' + file.originalname);
  } => 동일하고, cb의 첫 번쨰는 에러, 두 번쨰는 파일명
})
(파일명이 동일하면 덮어쓴다.)

3. const upload = multer({ storage });
=> multer.diskStorage 작업이 끝나면 multer을 호출하고 객체에 넣으면 formdata를 처리하는 미들웨어가 생성된다.


4. upload
4-1. upload.single('image');
=> 단일 파일을 업로드한다./ req.file에 파일 정보가 저장된다.

4-2. array(fieldname[, maxCount])
=> 하나의 필드에 대해 여러 파일을 업로드한다./ req.files 배열에 저장된다.

4-3. none()
=> 파일 없이 폼 데이터만 처리한다.
=> req.body에 저장한다.


5. fileFilter와 mimetype
5-1. mimetype => 파일의 종류와 형식을 식별하기 위한 클라이언트와 서버의 header의 Content-Type
5-2. Content-Type : application/json, text/html, image/png...

5-3. fileFilter는 파일이 저장되기 전에 filtering하는 함수이고 객체의 값으로 들어가는 미들웨어 옵션이다.
ex) const filefilter = (req, file, cb)=>{
    if(file.mimetype === 'image/jpeg' || file.mimetype === 'image/png'){
        cb(null, true)
    } else {
        cb(null, false)
    }
}
=> cb의 첫 번쨰 인자는 에러를 트리거한다. => null이 아니라면 오류로 간주하고 파일 업로드를 중단한다.
=> 일반적으로 if문을 사용해서 new Error('..')로 에러 처리를 하면 범용 에러 미들웨어가 처리한다.






