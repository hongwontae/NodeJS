1. const {MongoClient} = require('mongodb');
1-1. MongoDB에 접근하기 위한 초기 설정을 하는 객체이다.
1-2. 첫 번쨰 인자는 MongoDB의 URI이다.
1-3. 두 번쨰 인자는 객체로 옵션을 설정할 수 있다
1-4. uri 하나만 존재하면 필수 값은 채워진 것이다.


2. 이후 module.exports을 통해 내보내서 Root Node에서 사용한다.


3. client.connect();
3-1. DB을 연결하는 작업이다. close()를 호출하기 전까지 지속적으로 Node와 Server가 연결된다.


4. client.db('dbName');
4-1. 주어진 이름의 DB를 선택한다. 해당 이름의 DB가 존재하지 않으면 새로운 DB가 생성된다.


5. client.db(..).command(..);
5-1. 선택된 db에 내리면 명령어를 기술하는 메서드


6. client.db().collection('')
6-1. 컬렉션에 접근하는 메서드


7. client.db().collectio('').insertOne({...})
7-1. 하나의 데이터를 저장하는 메서드, 객체형식으로 주어야 한다.


8. //.insertMany([{}, {}])
8-1. 배열 형태의 객체를 받아들여서 컬렉션에 여러 개의 문서를 저장한다.


9. toArray()
=> 가져온 값을 배열로 바꾼다.


10. find({})
10-1. 조건에 맞는 모든 문서를 찾고 이를 커서 객체로 반환한다.
10-2. 커서 객체
1. MongoDB 쿼리의 결과를 탐색하는 방법을 제공하는 객체
2. 결과 반복을 통해 각 문서를 개별적으로 처리 가능
3. 대량의 데이터를 한 번에 로드 x, 필요한 만큼 읽어오는 방식으로 메모리 사용 최적화
=> 쿼리를 날리면 커서객체를 통해서 직접적인 데이터를 fetching해온다.

10-3. 만약 일치하는 id을 찾으려고 하고 id 생성을 DB에 의존했다면 ObjectId 형식으로 비교해야 한다.
10-4. find({id : new mongodb.ObjectId(id)});
10-5. find().next() : 첫 번쨰로 일치하는 데이터를 가지고 온다.

10-6. findOne() : 첫 번쨰로 일치하는 문서를 찾아서 반환하고 결과값을 Promise에 담긴 채 반환한다.


11. updateOne()
11-1. 첫 번쨰 인자로 업데이트 대상 문서를 찾는다.
11-2. 두 번쨰 인자로 객체를 받고 {$set : {업데이트 데이터}}을 넣어주면 된다.
11-3. Promise를 반환한다.


12. deleteOne()
12-1. 인자로 삭제할 문서를 식별할 객체를 받는다.
12-2. Promise을 반환한다.


13. NoSQL에서의 관계

13-1. users-products의 관계가 존재할 떄 장바구니 로직
1. products가 추가될 떄 users의 항목에서 items는 배열을 갖고 하나의 배열 데이터는 객체이고 해당 객체 데이터는 products의 _id와
quantity을 갖는다.
2. SQL과 다르게 다른 컬렉션과 관계를 가질 떄는 데이터를 추가하는 방식으로 이루어지고 잦은 변화가 있을 것으로 예상대면
바뀌지 않는 데이터를 참조하는 방식이 좋다. (_ID)


14. find 같은 메서드로 데이터를 가져올 떄 _id는 문자열이 아니다. => ObjectId 타입의 데이터이기 떄문에 toString()을 해야 문자열
타입이 된다.








